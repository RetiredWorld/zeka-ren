---
date: 2021-01-26
title: 从 Nuxt 查看 CORS 行为
tags: []
---
CORS 是浏览器为了避免恶意请求做出的一项保护措施。其行为由浏览器控制，而决定是否放行则由服务器添加相应请求头，由浏览器检查完成。

换句话说，如果没有浏览器的限制，正常的请求是不可能出现 CORS 问题的。

Nuxt 恰好是 SSR 框架，也就是说部分请求是在服务端完成的，部分请求是在浏览器完成的。可以考察这一限制。

在服务端的请求不受到浏览器影响，因此只要接口无误，就能保证渲染出来。但是在浏览器就没有那么简单了。

要弄明白的一点是，对于前后端开发，CORS 基本是由后端配置的，前端只需要关心能否请求到数据。前端不需要关系的原因为浏览器自动完成了所有操作。而后端则往往由对应模块完成。

步骤大概是这样的（[阮老师的教程](https://www.ruanyifeng.com/blog/2016/04/cors.html) 写的很详细）：

前端发起请求，浏览器检查请求头，查看是否为简单请求（简单来说，header 足够简单，请求局限于 POST 和 GET，默认是不带 cookie 的）。

如果是简单请求，则浏览器在 header 添加 `origin`，并说明 origin（域名）。之后再检查服务器的回应，不管服务器响应的 body 是什么，只检测 header,如果没有出现 `Access-control-allow-origin` 字段，或者不合法，那么此次请求就会被丢弃。也就是说数据到了浏览器，但是被浏览器拦截了，不允许 JS 拿到数据并进一步动作。如果存在请求头，则数据正常到达，表现和没有跨域一样。

如果是非简单请求，则浏览器首先发出的不是我们的请求，而是一个 `OPTIONS` 类型的请求（请求自然不带响应内容）。对于有 CORS 模块的后端，会返回几个字段：

- Access-Control-Request-Method
- Access-Control-Request-Headers
- Access-Control-Allow-Origin

非简单请求与简单请求的区别就是方法与 header，这也就是预检请求的意义。预检请求检查方法与响应头是否允许。如果不被许可自然就拦截了。如果通过，就再发起请求。也就是说需要请求两次。为了不频繁发送请求，浏览器会对预检请求进行缓存，从而避免多次 OPTIONS 请求。

此外不论是简单请求还是非简单请求，对 cookie 都有更严格限制，比如 `Access-Control-Allow-Origin` 必须详细指定域名，不能是宽泛的 `*`，还需要加上额外的 `Access-Control-Allow-Credentials = true` 的 header。

对于正确配置了 CORS 的后端，会按照期望进行响应。接下来分析下没有配置 CORS 的后端服务器行为。

对于没有配置 CORS 的后端，有什么请求就会有什么响应。最大的特点是一定不会有 CORS headers。对于简单请求，即使数据送到了浏览器，浏览器也会拦截并丢弃。对于非简单请求，OPTIONS 请求后端无法进行正确答复，请求无法继续，即使后端进行了正确响应，浏览器也会拦截。

CORS 只能阻止接口被滥用。假设有一台正确配置了 CORS 的银行服务器 A ，那么恶意页面 B 就无论如何无法对 A 发送合法的转帐请求，从而避免了安全事故。

但是 CORS 不是万能的。比如它无法防范信息收集。毕竟信息收集的服务器是由坏人控制的，他知道要配置好 CORS 从而窃取用户信息。此外，如果对于本站点发动了 XSS 攻击，那么请求是不会触发 CORS 的，浏览器无法拦截。

对于不能让其他页面随随便便调用的 API(比如用户数据)，CORS 应该尽可能阻止请求，只运行在自己的域名上使用。而对于一些开放接口（比如 [一言](https://hitokoto.cn/#) 的接口），它们需要能够在不同页面展示，就需要设置所有域名允许访问了。

上面是在应用层次。随着前后端分离的影响，数据接口与页面接口渐渐分离，导致了跨域问题频发。对于简单页面，虽然部署时可以通过 nginx 统一，但是开发的时候还是经常遇到。对此的解决方案是后端安装并正确配置 CORS 即可。此外，虽然是开发环境的解决方案，但是完善 CORS 总归是没错的，因此开发完成后不需要移除 CORS（当然还是需要合理配置）。